### 锁问题

通过锁机制可以实现事务的隔离性要求，使得事务可以并发地工作。

> 感觉这些不是锁造成的问题，而是并发问题。

#### 脏读

脏读（`Dirty Read`），指读取到脏数据。

脏数据（`Dirty Data`），指未提交的数据。

> 读到未提交的数据
>
> 违反了事务的隔离性

> 加X锁

#### 不可重复读

指在一个事务内多次读取同一数据，读取到的数据不一致。

> 读取到其他事务对此数据的修改

> 加S锁
>
> 在`InnoDB`存储引擎中，通过使用`Next-Key Lock`算法来避免不可重复读的问题，
>
> <span style="border-bottom:2px dashed yellow;">在`MySQL`官方文档中将不可重复读问题定义为幻读。</span>
>
> <span style="border-bottom:2px dashed yellow;">临键锁是记录锁+间隙锁，天生就解决了不可重复读和幻读的问题。</span>



#### 幻读

读取到其他事务新增的数据。

> 加临键锁解决



#### 死锁

死锁是指两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。

死锁的处理方式

* 超时
* 等待图（`wait-for graph`）

`InnoDB`采用的就是等待图的方式，等待图要求数据保存锁的信息链表，事务等待链表。

通过上述链表构造一张图，若图中存在回路，就代表存在死锁。

等待图是一种主动检测死锁的机制，每个事务请求锁并发生等待时都会判断是否存在回路，

若存在则有死锁，通常`innoDB`存储引擎选择回滚undo量最小的事务。

